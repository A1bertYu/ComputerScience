#INTRODUCTION TO ALGORITHM
second edition 潘金贵译 机械工业出版社
##第2章 算法入门
###Insertion sort
伪码  

	INSERTION_SORT(A)
	for j = 2 to n
		key = A[j]
		i = j-1
		while(A[i] > key && i > 0)
			A[i+1] = A[i]
			--i
		A[i+1] = A[j]

循环不变式（loop invariant）  
三个步骤，分别对应循环前，循环中和循环后：  
（1）初始化：先证明第一轮迭代之前，循环不变式是成立的；  
（2）保持：每一轮循环都能使循环不变式保持成立。  
（3）终止：循环结束后，证明循环不变式成立。  
上述所谓的循环不变式，是指与循环有关的某个变量（如已排序数组），在每次循环后，性质保持不变。例如，对于插入排序，每一次循环后产生的已排序的子数组，其称循环不变式。  
循环不变式与数学归纳法是很相似的，前两步一样，第三步前者是到循环结束（有限），后者则是归纳到无穷（无限）。  
插入排序是增量（incremental）方法，即在已排序的子数组中，将后续元素插入，形成最后的结果。
插入排序是**原地排序**，即在排序输入数组时，只有常数个元素被存放到数组以外的空间中去。
###算法分析
>一般来说，算法所需时间是与输入规模同步增长的，因而常常将一个程序的运行时间表示为其输入的函数。这就要求对术语“运行时间”和“输入规模”更加仔细地加以定义。（P13）

对于要分析的程序（即算法具体的实现，可以是伪代码），假定其每条语句运行时间为常数（每条语句对应不同常数），并计算出其执行次数（与输入有关），再对所有语句的用时求和，便可进行复杂度分析。算法性能通常与输入有关，且一般是用最坏情况进行衡量。
###算法设计
* 分治法  
将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并结果，就得到原问题的解。  
分治法在每一层递归中，都包括三个步骤：分解（Divide），解决（Conquer）和合并（Combine）。分解是将原问题分解成一系列子问题；解决是递归地解决各子问题（若子问题足够小，直接求解）；合并是指将子问题的解进行合并而得到原问题的解。
* Merge sort  

		MERGE(A, p, q, r)
		n1 = q - p + 1
		n2 = r - q
		create arrays L[1,...,n1+1] and R[1,...,n2+1]
		for i = 1 to n1
			L[i] = A[p+i-1]
		for j = 1 to n2
			R[j] = A[q+j]
		L[n1+1] = +inf
		R[n2+1] = +inf
		i = 1, j = 1
		for k = p to r
			if L[i] <= R[j]
				A[k] = L[i++]
			else
				A[k] = R[j++]
对于上述合并，有两点值得注意：（1）**哨兵元素的使用**，这样避免尾部的检测（若不使用，需要比较i或者j是否到达了n1或者n2，这样每一次循环多了两次比较）；（2）循环的设计，设计为一次循环就完成A数组的求取，这种情况下其实不用担心L或者R越界的。（1）是（2）的基础，有了（1）之后才能设计（2）的循环。  
有一种容易想到的解法是用while循环，来确保L，R不越界，在循环体内比较L和R的元素之后再赋值给数组，退出循环之后再将没有遍历完的数组赋值给数组A。该解法其实在每次循环都检测了尾部，多做了一次比较工作（L和R是否越界n1和n2，而此处所列解法只需判断是否越界r），因此不及此处所列解法。	

		Merge sort
		MERGE_SORT(A, p, r)
			if p < r
				q = floor((p + r)/2)
				MERGE_SORT(A, p, q)
				MERGE_SORT(A, q+1, r)
				MERGE(A, p, q, r)	
**理解递归**：对于合并排序中的递归，可以这么理解，递归调用时，最开始是直达底层，底层的整个函数处理完后（如本例中的两次合并排序递归再合并），再返回至上一层的递归调用处，沿着该处继续处理这一层的语句，若在这一层的后续中又遇递归，则又是直达底层，继而依前述流程执行。（可通过观察图2-4的执行过程进行体会学习）有些情况下我们会遇到**尾递归**，尾递归可以理解为一系列的代码展开，只是到达最底层后再逐层上浮。


* 分治法分析  
	根据分治法的特点，其执行时间可以用递归式进行表示**T(n) = aT(n/b) + D(n) + C(n)**, 其中D(n)和C(n)分别表示分解该问题和合并子问题的解的时间，而且在n小于某个值时，T(n)是常数。对比数列的**通项公式**，两者有点类似，可比较学习。
##第3章 函数的增长
渐进记号，定义的是一个集合，此外，其不等式成立的条件类似于证明数量极限时，只有对n > N时才成立。另外，算法性能的函数定义域是自然数集，且为正函数。

##第4章 递归式
在第2章分治法分析中提到了类似与数列通项公式的递归式。该递归式又可以写做：  
>T(n) = aT(n/b) + f(n) 其中，a >= 1, b > 1, f(n)是已知函数。b > 1体现了递归解决的方式是将大问题划归为小问题，这样才能求解，总不能越分越大吧！

关于递归式的解法，本章介绍了代换法、递归树和主定理两种方法。  

* 代换法  
	步骤，先猜测（需要经验甚至创造性），再用数学归纳法去证明。  
	证明时，最后推到出的表达式的结果一定要与猜测的相同，比如，假设T(n) <= cn,那么最后导出的是T(n)<=cn+1，这也是不满足要求的。当然，这样缩放式证明是可以的：T(n) <= cn-1 < cn  
	需要注意的地方是，要避免陷阱，比如T(n) <= cn，证出T(n) <= cn + n并没有得证，因为假设与最后导出的表达式要一致。  
	有些情况也可以使用变量替换法，求出结果后再替换回去。

* 递归树  
	画出一个递归树是一种得到好猜测的直接方法。递归的层数是最先使通项中T(n/b)中的自变量为1的层数（一般在T(c)递归到达底部，c为常数，假定为1与假定为其它常数也只差一个常数项，不影响分析），层数k满足等式power(b, k) = n。观察图4-1，每一层按等比为a进行裂变，直至到最后一层，因此，图4-1最后一层的项数为n*log(b,a)（注意，power(a, log(b,n)) = power(n, log(b, a))，参考3.15式）。

* 主方法（master method）  
	从图4-1递归树中的各层执行时间来看，在最后一层，执行时间已经与f(n)无关，而与power(n, log(b, a))有关，但前面各层的执行时间则与f(n)有关，因此，主方法推导出了三种情况，即根据f(n)与power(n, log(b, a))的关系，T(n)有不同的渐进界。   
	第二种情况递归层数是lgn，所以有该系数  
	第三种情况有个附加条件，来历可以参考图4-3  
	多项式小于（polynomially smaller），差一个power(n, epsilon)因子，epsilon为某大于0的常数。
##第5章 概率分析和随机算法
###雇佣问题
均匀的随机排列，对于n个元素的数组，其有n!种出现的次序，若每一种次序出现的概率都相同，则称为均匀的随机排列。
###指示器随机变量
首先回顾一下概率论的一些基本定义。  
**随机试验**：（1）可以在相同的条件下重复进行；（2）每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果；（3）进行一次试验之前不能确定哪一个结果会出现。  
**样本空间**：随机试验E的所有可能结果组成的集合称为E的样本空间，记为S。  
**样本点**：随机试验E的每个结果，称为样本点。  
**随机事件（简称事件）**：样本空间S的子集为随机试验E的随机事件。在每次试验中，当前仅当这一子集中的一个样本点出现时，称这一 **事件发生**。  
**基本事件**：由一个样本点组成的单点集，称为基本事件。  
**随机变量**：设随机变量的样本空间为S={e}（注意：是集合），X=X(e)是定义在样本空间S的单值函数。称X=X(e)为随机变量。例如，X是投掷3次硬币得到正面的次数，在这个试验（投掷硬币3次）中，样本空间S可以确定，X的值也能确定，X的定义域显然是属于S的。对于某随机变量，其值的概率之和为1.  
**指示器随机变量**，关于随机事件A的函数，A发生值为1，A不发生值为0.显然，指示器随机变量的期望等于事件A发生的概率。增加了一层间接性，在寻找问题解决方法时多了一种思路，特别是在分析重复随机试验中的情况时。  
**应用例子**：  
（1）统计抛掷一枚硬币时正面朝上的期望次数。每一次抛掷时也对应一个随机事件，因此可以将每次抛掷的正面朝上事件用指示器随机变量来包装，总次数（也是随机变量）就是各指示器随机变量之和。  
（2）雇佣问题。雇佣新的办公助理的次数，假设应聘者以随机顺序出现，前i个应聘者中的任何一个都等可能的是目前最具资格的，因此，应聘者i被雇佣的概率为1/i，因此，雇佣次数就是所有应聘者被雇佣的期望之和。
###随机算法
许多随机算法通过排列给定的输入数组来使输入随机化。  

* 随机排列数组  
	一种常用的方法是为数组的每个元素A[i]赋予一个随机的的优先级P[i]，然后根据优先级对数组进行排序。  

		PERMUTE_BY_SORTING(A)
		n = length(A)
		for i = 1 to n
			P[i] = Random(1,n^3)
		sort A, using P as sort keys
		return A
	上述伪代码假定所产生的优先级都是唯一的，即数组P元素值各异
	关于上述产生的排列，其属于均匀随机排列的证明，思路是对于任意序列，证明其出现的概率为1/n!，书中对一种特殊情况，即第一个元素最小，第i个元素第i小，进而可以证明。其实，可以这样做更一般的假设，即第i个元素第j小，此时，依旧即该事件为Xi，进而可以得到同样的概率求解式子，只是在进行条件分解时，先分解第1小的，其次再是第2小的，以此类推，这样可以得到与书中特例的相同解1/n!。

		RANDOMIZE_IN_PLACE(A)
		n = length(A)
		for i = 1 to n
			swap(A[i], Random(i, n))
	<font color='red'>证明还有待添加</font>
###概率分析和指示器随机变量的进一步使用
* 生日悖论  
	求房间里的最少人数，使两个人有相同生日的机会超过50%。  
	书中给出了两种解法，都很有参考价值。对于第一种直接使用概率分析的解法，书中是从反面进行了求解，即所有人生日都不相同的概率，并且在通过通项的形式来进行推导，这种角度很值得学习。第二种使用了指示型随机变量，如何合理的设定指示型随机变量也是很有技巧的，书中是将两人生日相同的事件包装成了指示型随机变量（此时变量的意义是生日相同的对数（pair，不是log）），在假设所有人生日都独立，且所有人生日均匀分布在全年各天的情况下，求出两人生日相同的概率为1/n，进而可以求出指示型随机变量的期望，最后求出了生日相同的对数（pair，不是log）的期望，虽然没有按题意解答问题（50%概率），但也看到了另一种思路。
	<font color='blue'>关于该问题的一些思考：第一种解法显然是将生日组合划分成了两块，第一块是生日各不相同，第二块是生日不是各不相同（即两个人或者以上有相同的生日，这也是所要解决的问题），解法一是从反面解决该问题的。第二种解法，最开始以为是与第一种解法类似，只是从正面直接去计算概率（第二块的概率），且以为只考虑了两两相同的部分，而两两相同的部分因为重叠原因，也包括了三个相同四个相同...全部相同，但这样还是多算了，毕竟三个相同等也只是多个两两相同组成的。后来仔细思考了一番，发现理解错了，指示型随机变量虽然是指示的两人生日相同的事件，且其期望是两人生日相同的概率，**但多个指示型随机变量之和并不是概率**，而是两人生日相同这种事件发生的数量，这点一定要理解清楚，若是概率，人数很多时，岂不超过了1？此外，解法二只是求解了这种事件能发生（期望大于1）的人数，而未考虑大于50%的题意要求</font>
* 球与盒子  
	<font color='red'>本小点以及本章后续以后再补充。</font>
##第6章 堆排序
代码紧凑的算法，其运行时间所隐含的常数因子就很小。堆排序综合了插入排序（原地排序，in place）和合并排序（运行时间）的优点。
>堆排序还引入另一种算法设计技术：利用某种数据结构（在此算法中为“堆”）来管理算法执行中的信息。（P73）
###堆
二叉堆数据结构是一种数组对象，它可以被视为一颗完全二叉树。表示堆的数组A具有两个属性：length(A)表示数组中元素的个数，而heap-size(A)表示存放在A中堆的元素个数，而且heap-size(A)小于等于length(A)，A[1...heap-size(A)]中的元素为堆中的元素，其余元素则不是堆中的元素。树的根为A[1]  
		
	PARENT(i)
		return floor(i/2)
	LEFT(i)
		return 2*i
	RIGHT(i)
		return 2*i + 1
二叉堆分大根堆和小根堆，在大根堆中，节点i需要满足的性质是A[PARENT(i)] >= A[i]；小根堆则是A[PARENT(i)] <= A[i]。

	MAX_HEAPIFY(A, i)
	l = LEFT(i)
	r = RIGHT(i)
	largest = i
	if l <= heap-size(A) && A[i] < A[l]
		largest = l
	if r <= heap-size(A) && A[largest] < A[r]
		largest = r
	if largest != i
		swap (A[i], A[largest])
		MAX_HEAPIFY(A, largest)
上述代码通过数组中元素位置，来使得最大堆性质得以保持。关于上述代码的时间分析，元素i肯定与下标比自己大的元素（子女元素）交换（若需要交换的话），随着下标的增大，渐渐的会使得递归返回。那相邻的递归之间运行时间有什么关系呢？通过代码，可以列出通项T(n) = T(n/b) + C，那最坏的情况肯定是b最小的情况，也就是问题规模减少的最少，也就是子树结点数量最大可能的占比，借助图6-2，若是对A[1]进行调整（根结点），且若递归的是左子树（并且图6-2中A[5]要有右子女），此时左子树占比最大6/11，小于2/3，之后的递归不会比6/11大，因此缩放得到书中的递归式。
	 
	BUILD_MAX_HEAP
	heap-size(A) = length(A)
	for i = floor(length(A) / 2) downto 1
		MAX_HEAPIFY(A, i)
在建堆的过程中，叶结点是不需要管的，因为其没有子结点，无需考虑堆的性质（父结点与子结点关系）。此外，建堆的过程是从下到上来进行建立。  
	
	HEAP_SORT
	BUILD_MAX_HEAP
	for i = length(A) to 2
		swap(A[1], A[i])
		heap_size(A) = heap_size(A) - 1
		MAX_HEAPIFY(A, 1)
	

##第13章 红黑树
红黑树：满足如下红黑性质的二叉查找树，称为红黑树，即：根黑，父红子必黑，叶节点黑，每个结点开头的所有路径具有相同的黑结点数目。

##附录

###B.5
* 几个定义  
**自由树**：一个**连通且无回路**的无向图。  
**森林**：非连通且无回路的无向图。  
**有根树**：一颗自由树，但其有一个与其它点不同的结点，这个特殊的顶点称为树的根。  
**有序树**：子女节点有序的有根树。  
**二叉树**：是定义在有限集上的结构。要么不包括任何结点（称为空树或零树，用NIL表示），要么由三个不相交的结点集构成：根结点，一个称为左子树的二叉树和一个称为右子树的二叉树。  
**二叉树与有序树的关系**：二叉树更严格一点，例如，某结点其只有左子女或者右子女，这两种情况对应两种二叉树，而对有序树来说，这两种情况是不做区分的。  
**位置树**：结点中的子女用不同的正整数标识，若没有结点被标识成整数i，则该结点的第i个子女缺失。  
**K叉树**：每个结点的标识超过k的子女均缺失的位置树。  
**完全k叉树**：所有叶结点都有相同深度，并且所有内部结点度都为k  
**度**：结点x的子女数目称为度。  
**外部结点（叶结点）**：没有子女的结点。  
**内部结点**：非叶结点称为内部结点。  
**深度**：从根结点r到结点x路径的长度称为x的深度（即边数）。  
**高度**：从结点向下至某个叶结点最长简单路径中边的条数。  
**树的高度**：树中结点的最大深度，也是根结点的高度。  
深度和高度不要混淆，两者都是用边数来衡量，且可以理解二者有互补之意，即一个结点在这两个方面不可能同时都很大（好处不能都占，是吧？）。

