##TCP/IP详解 卷1  
机械工业出版社  中文第1版  
###第1章 概述  
TCP/IP协议族是一个四层协议系统：链路层、网络层、运输层和应用层。网络层有时也称为互联网层。运输层为两台主机的应用程序提供端到端的通信。TCP/IP协议族有TCP和UDP两个互不相同的传输协议。  
应用层和运输层使用端到端（End-to-end）协议，网络层提供的却是逐跳（Hop-bay-hop）协议。  
网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连。TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议。  
**IP地址**：五类，D类和E类较为特殊，只有ABC三类常用，由网络号和主机号组成。  
**以太网帧**：通过以太网传输的比特流称作帧（Frame），由以太网首部（14字节）、以太网数据帧（46-1500字节）和以太网尾部（4字节）组成。
  
###第2章 链路层  
* 三个目的  
	（1）为IP模块发送和接收IP数据报  
	（2）为ARP模块发送ARP请求和接收ARP应答  
	（3）为RARP模块发送RARP请求和接收RARP应答  
* 多种硬件  
	TCP/IP支持多种不同的链路层协议，包括以太网、令牌环网、FDDI和RS-232等。  
* RFC894和RFC1042  
	RFC894也称为以太网IP数据报，而RFC1042称为IEEE 802网络的IP数据报。目的地址和源地址都是48bit，类型为两个字节，用于区分IP/ARP/RARP。RFC1042定义的帧格式包含了更多内容。  
	RFC894规定的帧，数据部分（以太网数据帧）至少是46字节，也就是整个以太网帧长至少有14+46+4字节.而RFC1042的数据部分至少是38字节。  
* SLIP和PPP  
	在串行线路上对IP数据报进行封装。  
	SLIP有很多缺陷：（1）必须知道对方的IP地址；（2）数据帧中没有类型字段，若一条串行链路用于SLIP，则不能同时使用其它协议；（3）SLIP没有在数据帧上加上校验和。  
	PPP修改了SLIP的所有缺陷。  
* loopback interface  
	传给环回地址的任何数据均作为IP层的输入（再往上传至传输层）。  
	本机广播和多播的数据会复制一份传输至环回接口，注意图2-4中，多播/广播并不经过ARP，而是直接到链路层  
	传递给自身的数据会发送至环回路口，依旧要注意图2-4，此种情况下并不会发送至链路层。  
	**对于图2-4**，要认真学习，哪些些数据会放入到IP输入，以及哪些方式会到链路层，是否要经过ARP？   
	**环回接口可以被看作特殊的链路层**  
* MTU  
	不同的链路层协议有不同的MTU  
* 路径MTU  
	两台主机通信路径中的最小MTU，称为路径MTU。注意，该值取决于当时所选择的路由，且来回路径不一定相同，因此，两个方向的路径MTU不一定相等。  
###第3章 IP：网际协议  
* 不可靠与无连接  
	 不可靠（unreliable）表示它不能保证IP数据报能够成功地到达目的地。IP仅提供尽力而为的传输服务。  
	 无连接（connectionless）表示IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。  
* 传输次序，big endian（网络字节序）  
	 对于little endian格式，必须在传输之前把**首部**转换成网络字节序。  
* IP首部  
	若没有选项字段，则为20字节。IP首部始终是32bit的整数倍。  
	（1）首部长度和总长度  
	首部长度是指首部长度（单位是32bit，也就是说对于没有选项的首部，其长度为5*32bit=20字节）；总长度（单位是字节）是指整个IP数据报的长度（首部+数据）。  
	（2）TTL（time-to-live）  
	设置数据报可以经过的最多路由器数。一旦经过一个处理它的路由器，其值减1，当该值为0时，数据报被丢弃，并发送ICMP报文通知源主机。第8章（P71）中写到，减1或者减去数据报在路由器中停留的秒数（但很少有路由器这么实现）。TTL被作为一个跳站计数器。  
	（3）首部“校验和”   
	不对首部后面的数据进行计算。  
	计算方法：首先把“校验和”字段清零（发送时，接收时不做此操作），再对首部中的每个16bit进行二进制反码，再求和，最后将得到的16bit结果存放于首部“校验和”字段。  **接收方计算的结果应该为0xFFFF才算接收正确**。若接收错误，则丢弃，但不生成差错报文，由上层去发现丢失的数据并进行重传。  
* IP路由选择  
	IP层可以配置为路由器功能或者（和）主机功能。IP层在内存中有一个路由表。  
	逐跳（hop-by-hop）进行。为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模。（网络地址：主机号全为0；主机地址：有一个非0的主机号，参考图1-5 IP地址的结构）  
* 子网寻址  
	IP地址由“网络号”+“主机号”，扩展为“网络号”+“子网号”+“主机号”。（即原来的主机号前面的一部分用作子网号）。  
	子网对于外部Internet路由器是透明的。  
	子网掩码：网络号和子网号对应的位为1，主机号对应的位为0.  
	给定IP地址和子网掩码以后，主机就可以根据目的IP来确定：（1）本子网上的主机；（2）本网络中其它子网上的主机；（3）其它网络上的主机。  
	**掩码的作用即为上述三点，IP地址一样，但子网掩码不同时，解析得到的子网号是不同的**
* 特殊IP  
	参考图3-9  
* 变长子网  
	不同的网络需要使用不同的子网号（比如以太网网络和点对点链路），为了让这些网络的主机都使用相同的子网号，就需要使用变长子网，也就是将各自的原子网占用比特位数增加，超过所有的子网占用比特数，比如由8位扩张到11位，多出来的比特用于区分具体是原来的哪种子网。  
###第4章 ARP：地址解析协议  
ARP将IP地址转换为**以太网**硬件地址。  
ARP广播ARP请求至以太网上的每台主机。请求报文中包含目的以太网  

* ARP的分组格式  
	包括请求和应答。目的地址为全1的特殊地址是广播地址。格式中包含硬件类型和协议类型，证明ARP不只是用于以太网和IP。<font color='red'>协议类型有哪些？</font>  
	ARP请求是广播的，但应答不是广播的。  
	对一个ARP请求来说，除了目的端硬件地址没有值之外（因为ARP就是为了将IP映射为硬件地址，所以请求时肯定没有值了），其它字段都有值。
* ARP代理  
	ARP请求从一个网络的主机发往另一个网络的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理（Proxy ARP）  
* gratuitous ARP  
	主机发送ARP查找自己的IP地址（注意请求时目的端硬件地址是没有的，通过目的IP来查找目的硬件地址）。作用：（1）主机通过它确定另一个主机是否设置了相同的IP地址；（2）如果主机正好改变了硬件地址，那么就可以让其它主机更新硬件地址。  
	一个应用：主备服务器下，若主服务器出现故障停用，那么可以将备用服务器IP设置为主服务器IP，之后发送gratuitous ARP，那么，通过ARP更新，使得备用服务器接替了主服务器的工作。  
* ARP  
	ARP缓存有有效期限，也可以增加永久性ARP。
###第5章 RARP：逆地址解析协议  
具有本地磁盘的系统引导时，一般从磁盘上的配置文件中读取IP地址。然而，对于无盘机，如何获取IP地址却是个问题。  
无盘机有网卡硬件，因此，可以发送该硬件地址至RARP服务器，以获得该硬件地址对应的IP，之后便读取引导映像。  
RARP请求以广播方式发送，而应答一般是单播的。  
RARP使用链路层广播，这样使得大多数路由器不会转发RARP请求。对于这句话的理解，要结合ARP请求，ARP请求也是使用链路层广播，但其给出了目的IP地址，这就使得路由器可以转发（路由）请求。但是RARP给的硬件地址，而路由表中只有IP信息，这就没法路由了。  
###第6章 ICMP：Internet控制报文协议  
ICMP传递差错报文以及其它需要注意的信息，通常被IP层或更高层协议（TCP或UDP）使用。  
ICMP报文在IP数据报内部传输。  
ICMP报文分查询报文和差错报文两类。对差错报文的响应，不能是生成另一份差错报文。  
ICMP的标识符和序列号可由发送端任意选择设定，这些值在应答时将被返回。    

* 不产生ICMP差错报文的情况（防止广播风暴）：   
	（1）对ICMP差错报文进行响应时  
	（2）目的地址是广播地址或多播地址的IP数据报  
	（3）作为链路层广播的数据报  
	（4）不是IP分片的第一片  
	（5）源地址不是单个主机的数据报。（源地址不能为零地址、环回地址、广播地址或多播地址）  
* ICMP地址掩码请求与应答  
	用于无盘系统在引导过程中获取自己的子网掩码（无盘系统获取子网掩码的另一种方法是BOOTP协议）。注意，由图6-1的报文格式，ICMP报文会被填充IP首部的。  
	IP首部中有发送端和目的端IP，若目的地址是广播地址，则本机地址也会应答ICMP掩码请求（返回环回地址对应的子网掩码）。  
* ICMP时间戳请求与应答  
	向另一个系统查询当前时间，返回的值是自午夜开始的毫秒数（但是因为没有提供日期，所以必须以其他方式去获取日期），提供毫秒级的分辨率。因为各操作系统实现不同，有的仍然只提供到秒级。  
* ICMP端口不可达差错  
	该报文属于差错报文。  
	书中举了TFTP的一个例子，客户端有意连接不正确的UDP端口，并发送UDP报文，使得服务器返回一个ICMP不可达报文。  
	注意图6-5中的差错报文格式，包含了产生差错的数据报的IP首部（包含协议字段，用于解释后面的8个字节），以及该IP首部后面的8个字节  
###第7章 ping程序  
目的是为了测试另一台主机是否可达。发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。  
一台主机的可达性可能不只取决于IP层是否可达，还取决于使用何种协议以及端口号。  
ping程序通过在ICMP报文数据中存放发送请求的时间值来计算往返时间。

* IP记录路由选项   
	利用IP首部的选项字段进行，最多可记录9个IP。每个处理该数据报的路由器都把它的IP地址放入选项字段中。对于路由器，一般放出口的地址  
* IP时间戳选项  
	可以记录经过某IP对应的时间，也是利用IP首部选项字段进行。  
###第8章 Traceroute程序  
Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。  

* 实现原理  
	（1）当接收到TTL字段为0的数据报时，路由器将该数据报丢弃，并发送一份ICMP超时信息；  
	（2）Traceroute发送一份UDP数据报给目的主机，但选择一个不可能的值作为UDP端口号，使得目的主机的任何一个应用程序都不可能使用该端口。当该数据报到达时，使得目的主机的UDP模块产生一份端口不可达错误的ICMP报文。  
	利用上述两点，以及可设置发送TTL的权限。  
* 实现细节  
	源端口号，为traceroute进程ID与32768之间的逻辑或值。若一台机器上运行多个traceroute，那么**每个进程都查看ICMP返回的UDP首部的源端口号，而只处理那些对自己发送应答的报文。**  
* 注意事项  
	（1）当前探测到的路由并不一定是将来要采用的路由  
	（2）不能保证ICMP报文的路由与traceroute发送的UDP数据报采用同一路由  
	（3）返回ICMP报文中的信源IP地址是UDP数据报到达路由器接口的IP地址。（第7章中的IP路由选项是发送接口地址）  
* IP源站选路选项  
	通常IP路由是动态的。然而，应用程序可以指定路由，包含两种形式，严格的源站路由选择（SSRR）和宽松的源站路由选择（LSRR），前者指明IP数据报所必须采用的确切路由，而后者只要经过了指定的IP即可（也就是说可以经过指定IP之外的IP）。  
	通过IP首部的选项字段来实现，与“IP记录路由选项”类似。  
	运行过程：由图8-7所示，由应用程序指定了最终目的地址D和源路由清单（R1,R2,R3），那么发送主机发送前，将目的地址改为R1（因为指定了要经过R1），而将源路由清单改为（# R2,R3,D）；接着到了地址为R1的这一站，其会将目的地址改为R2，并将源路由清单改为（R1, #R3, D）（注意，#代表指针位置，此时指针移到了下一个目的地址，将到达时刻的指针所指向的内容改为当前地址，之后将指针下移一个单位）  
	对于8.5.2的图8-9示例，其分析如图8-10，其中，对于TTL=3的情况，是gateway发送不可到达，而源路由清单里面是有gateway的，为什么是gateway发送不可达呢？我们看到，8.5.2开头说了，正常的路由顺序是netb, gateway, butch和gabby，而路由清单里是好了butch的，也就是gateway无法发送到下一站了，故其会报发送不可达。  
###第9章 IP选路  
* 选路机制和选路策略  
	IP进行选路是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。  
	选路策略：一组规则，用于决定把哪些路由放入路由表。  
* 直接路由和间接路由  
	网关是间接路由，非网关是直接路由。当分组被发往一个间接路由时，IP是最终的目的IP，但链路层地址是网关的地址；当发往一个直接路由时；IP是最终的目的IP，链路层地址也是最终的链路层地址。
* 顶层选路域（top-level routing domain）  
	维护大多数Internet网站的路由信息，而不适用默认路由。  
* ICMP主机与网络不可达差错  
	当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文。  
* ICMP重定向差错  
	当IP数据报本应发送给R2，结果发给了R1，这时R1就应该要发送ICMP重定向差错报文给IP数据报的发送端。    
	重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。ICMP重定向允许TCP/IP主机在进行选路时不需要具备智能特性，而把所有智能特性放在路由器端。  
* ICMP重定向的注意事项  
	（1）重定向报文只能由路由器生成，而不能由主机生成，而且报文为主机使用而不是路由器使用，即路由器是生成者，而主机是使用者。  
	（2）路由器应该发送的只是对主机的重定向，而不是对网络的重定向。  
* ICMP路由器发现报文  
	主机在引导以后要广播或多播传送一份路由器请求报文，一台或更多台路由器响应一份路由器通告报文。另外，路由器定期地广播或多播传送他们的路由器通告报文，允许每个正在监听的主机响应的更新它们的路由表。  
###第10章 动态选路协议  
动态选路协议，用于路由器间的通信。  

* 内部网关协议(Interior Gateway Protocol)  
	也称为域内选路协议（intradomain routing protocol），是自治系统内部的各个路由器之间的选路协议。常见的IGP有RIP, OSPF等  
* 外部网关协议(Exterier Gateway Protocol)  
	选路协议，用于不同自治系统之间的路由器。  

* RIP：选路信息协议, Routing Information Protocol    
	 RIP报文包含在UDP数据报中，是采用距离向量的协议（每个路由器根据它所接收到邻站的这些距离向量来更新自己的路由表），其使用的度量是以跳（hop）计算的，跳数最大值为15，因此，这限制了网络的大小。  
* RIP2  
	相比RIP，其在报文中增加了子网掩码字段和下一站IP地址（这两个字段在RIP中都是0）  
* OSPF  
	OSPF是一个链路状态协议，每个路由器主动测试与其邻站相连链路的状态，将这些信息发送给它的其它邻站，而邻站将这些信息在自治系统中传播出去。  
###第11章 UDP：用户数据报协议  

* UDP首部  
	端口号表示发送进程和接收进程。UDP长度字段指的是UDP首部和UDP数据的字节长度，该字段最小值为8（也就是说允许发送0字节的UDP数据）。  
* UDP检验和  
	UDP检验和覆盖UDP首部、UDP数据和UDP伪首部（定义见后面） ，检验和是可选的。因为UDP数据报长度可以是奇数字节，而checksum的计算方法是每16bit字相加。解决方法是最后填充字节0，以构成16bit的整数倍，当然，填充的字节可以不发送。  
	伪首部：UDP数据报和TCP数据报都包含一个12字节的伪首部，它是为了计算检验和而设置的，伪首部包含IP首部的一些字段。  
	[关于伪首部的由来][pseudo_header_url]  
* 端到端的检验和  
	TCP和UDP的checksum都是end-to-end，保证end-to-end reliability。这与IP的checksum不同，那个是hop-by-hop的。此外，TCP/IP协议簇所有的检验和都是简单的16bit和，它们检测不出交换两个16bit的差错。因为这些检验和较为简单，不可能检测出所有可能发生的差错。  
* IP分片  
	IP层在发送IP数据报时，首先查询发送端口的MTU，并将其与数据报长度进行比较，若有需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。  
	对于分片的IP数据报，只有到达目的地才进行重新组装。分片和重新组装都由IP层完成，对运输层（TCP和UDP）是透明的。经过分片的数据有可能会再次进行分片。  
	对于分片的IP数据报，即使只丢失了一片数据，也要重传整个数据报。这是因为IP层本身没有超时重传机制，而TCP在超时后会重发整个TCP段报文，该报文段对应一份IP数据报，没有办法只重传其中的一片数据报。另外，若是中间路由器进行IP分片，那么起始端就无法知道数据报是如何被分片的。  
	在分片时，除最后一片，其它每一片中的数据部分（即不算IP首部）必须是8字节的整数倍。  
	注意图11-8 只有第一片有运输层首部，因此，若第一片丢失，则不会产生ICMP差错报文（因为没有端口号，无法区分是哪个进程所发送的数据报丢失）  
* ICMP不可达差错（需要分片）  
	当原始发送端设置了不分片（DF）标志，而中间路由器又需要进行分片时，此时就会发生ICMP不可达差错。
* 采用UDP的路径MTU发现  
	IP层对路径MTU的发现有定时器，若超时，则会将DF置1，也就是设置为不分片。在返回ICMP差错（需要分片）的报文中，可以设置是否返回下一跳MTU，若不返回，则原始发送主机只能猜测性的更改MTU  
* UDP和ARP的交互作用  
	书中举例IP数据报分为6片的情况，并且，实验前ARP缓存已经被清空。实验结果发现，在第一个ARP应答返回前，总共产生了6条ARP请求。这是因为产生了6个数据报片，而每个数据报片引发一个ARP请求。在接收到一个ARP应答后，只发送最后一个数据报片。这是符合规范的。  
	RFC规定，在等待一个ARP应答时，ARP至少保留一个报文，且这个报文必须是最后一个报文。此外，RFC也规定了，发送到同一IP地址的ARP请求，建议最高速率是每秒一次，显然，本例中的结果违背了该建议。  
	对于接收端，若第一个数据报片（注意，并非是指分片时的第一片）出现时，IP层必须启动一个定时器，若定时器超时，而该数据报的所有片没有完全到达，那么就丢弃。  
* 最大UDP数据报长度  
	理论长度 65535-20-8=65507  
	具体实现：（1）受到API的限制，socket API可以设置接收和发送缓存的长度；  
			 （2）TCP/IP内核的具体实现，这与源端和目的端的实现都有关系。  
	数据报截断：UDP socket可能会对数据报进行截断，丢掉多余的数据；也可能会通知用户进行多次读取；这与实现有关。  
* ICMP源站抑制差错  
	当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，可能产生ICMP“源站抑制（source quench）”差错。“可能”一词的意思是指不做强求。在有些UDP的实现中，即使接收到ICMP“源站抑制”差错报文，也将其忽略了，有一部分考量是，当收到ICMP source quench时，程序可能已经推出（因为UDP只管发，发完就可以退出）  
* UDP服务器的设计  
	<font color='red'>关于11.12.3所举UDP缓冲溢出例子存疑，两个客户端发送过来的数据没有溢出吧？当然，例子的目的还是清楚。</font>  
	注意翻译过来的几个名词，端点，IP地址和端口，端点其实算一个程序实例（一个程序打开2个称2个实例），程序（端点）会关联IP地址和端口。
###第12章 广播和多播  

广播和多播仅用于UDP，这对需要将报文同时传往多个接收者的应用来说非常重要。  

* 广播  
	（1）受限的广播  
	地址为255.255.255.255，用于主机配置过程中IP数据报的目的地址，路由器不得转发目的地址为该地址的数据报，因而，这种数据报仅出现在本地网络中。  
	（2）指向网络的广播  
	主机号全为1的地址。路由器必须能够转发指向网络的广播，是否发送必须可以设定。  
	（3）指向子网的广播  
	主机号全1，需要子网掩码的配合。  
	（4）指向所有子网的广播  
	子网号和主机号全1，需要子网掩码的配合。  
* 多播  
	多播提供两类服务：  
	（1）向多个目的地址传送数据；  
	（2）客户对服务器的请求，例如无盘工作站需要确定引导服务器，该服务可以通过广播或多播来完成。  
	使用D类地址，右边的28bit用于表示多播组ID。一个主机组（接收多播报文的主机）可以跨越多个网络，主机组成员可以随时离开或者加入，主机数量没有限制。  
	永久主机组，类似与知名端口概念。  
* 多播地址以及属于多播的以太网地址  
	01:00:5e:00:00:00到01:00:5e:7f:ff:ff属于以太网多播地址，注意到，其只有低23bit发生变化，而这低23bit对应到多播IP地址的低23位，从图12-3可以看出，IP地址还有5bit没有映射，也就是说这5bit可以是任意值，那么，就存在多个IP对应一个以太网地址的情况。  
###第13章 IGMP：Internet组管理协议  
多播是一种将报文发往多个接收者的通信方式。IGMP用于支持主机和路由器进行多播。它让一个物理网络上的所有系统知道主机当前所在的多播组。  

* IGMP协议  
	主机通过多播进程来支持多播功能（可以开启多个多播进程）。主机的每一个接口（如网口、串口）可以对应多个多播组地址，多播进程可以通过某接口来加入一个多播组。多播组中的成员是动态的，它随时因为进程的加入和离开而变化。  
	主机通过接口和组地址来识别一个多播组，主机必须维护一个表，此表至少必须包含正在被使用的多播组以及多播组中的进程数量。  
	**注意** 各接口可以对应相同的多播组地址（同一多播组），而一个进程可以在多个接口上加入同一多播组，这里的同一多播组是指组地址相同。书中还有一个细微之处，那就是主机通过组地址和接口来识别一个多播组，也就是说主机认为多播组除了地址外，还需要考虑所在接口，理解这点才能理解13.3.2中的规则。     
* IGMP报告和查询  
	当第一个进程加入一个组时，主机发送一个IGMP报告；若多个进程加入同一组（注意此处的同一组除了组地址相同外，还需要接口相同），只发送一个IGMP报告。  
	进程离开一个组时，主机不发生IGMP报告，因为多播路由器会定时查询多播组是否还有进程，路由器必须向每个接口发送一个IGMP查询报文。主机则发送IGMP报告来响应一个IGMP查询，且对于至少含有一个进程的多播组均要发回IGMP报告。   
	从图13-3所示，主机发送报告的目的地址是组地址，因此在一个物理网络中，所有主机将收到同组其它主机发送的所有报告(这是因为报告中的目的地址是组地址，注意，是目的地址，也就是说多播数据的发送的目的地址是组地址，而不是源地址)。若有主机在等待发送报告的过程中收到了其它主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组，只关心该组是否至少拥有一个主机。  
* TTL  
	在同一子网内传送时，则多播数据报的TTL被设置为1；当跨越子网时，需要设置为超过2；  
	224.0.0.0到224.0.0.255的特殊地址空间是打算用于多播范围不超过1跳的应用。不管TTL值是多少，多播路由器均不转发目的地址为这些地址的数据报。  
* 所有主机组  
	224.0.0.1被称为所有主机组地址，当接口初始化时，所有具备多播能力的主机自动加入该组，该组的成员无需发送IGMP报告。  
  

###第14章 DNS：域名系统  

DNS是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。  
一个名字服务器负责一个或多个区域，每个名字服务器必须知道根服务器的IP地址（而不是它的域名），根服务器则知道所有二级域中的每个服务器的名字和IP地址。  

* FQDN（Full Qualified Domain Name）  
以.结尾的域名称为绝对域名或完全合格域名，如sun.tuc.noao.edu.，若域名不以.结尾，则认为该域名是不完全的，域名的完整依赖于使用的DNS软件。

* DNS报文格式  
	由12字节的首部和4个可变长度的字段组成。   
	（1）查询问题字段  
		报文中4个可变字段中的第一个字段，该字段无需32bit边界结束，即无需填充字节。  
		字段中包含的查询名在没有压缩时，单字节指定随后的标识符长度，比如3www10dreamfruit2cn0，这样便存储了一个域名。因为标识符规定的长度范围为0-63，若将单字节的最高两位置1，则用于压缩格式。其原理是这样的，用于压缩格式时，那么单字节与其后一字节，除去最高的两位，还剩14位，这14位表示标识符所在的位置，由标识符字段的第一个字节算起。什么意思呢？看这种情况3www10dreamfruit2cn10timeishere10dreamfruit2cn，对于后面dreamfruit.cn重复的部分，便可用压缩格式。当然，具体实现再看，意思就是这样，有重复情况才需要考虑压缩。
	（2）资源记录部分  
		报文中4个可变字段中的后三个字段，回答字段、授权字段和额外信息字段，都采用一种称为资源记录（Resource Record）的相同格式。  
* 指针查询  
    给定一个IP地址，返回该地址对应的域名。  
      
* UDP还是TCP  
	DNS名字服务器使用的知名端口号，UDP和TCP都是53。当名字服务器返回的响应中TC比特被置1时，意味着响应长度超过了512字节，而仅返回前512字节，在这种情况下，通常使用TCP重发原来的查询请求。  

###第15章 TFTP：简单文件传送协议  

TFTP适用于只读存储器（存放所需要的UDP、IP和设备驱动程序），仅用于无盘系统进行系统引导。

TFTP使用UDP，数据传输采用停止等待协议，但因为UDP不可靠，TFTP必须处理分组丢失和分组重复。分组丢失可以通过发送方的超时与重传机制解决，<font color='red'>双方都超时与重传，解决方法？关于TFTP服务器在传送文件时，改变了端口号，以防止因文件传输时间过长导致端口号69一直被占用而无法接收新的请求，那TCP/IP中的80端口又是如何处理的呢？</font>

###第16章 BOOTP：引导程序协议  

BOOTP请求和应答均被封装在UDP数据报中，长度为300字节。  
当客户机进行系统引导时，引导请求采用链路层广播，目的IP为255.255.255.255（受限的广播，不会被转发），源IP为0.0.0.0  
BOOTP使用了两个知名端口号，BOOTP服务器使用67，BOOTP客户端使用68。我们知道，一般客户端使用的是临时端口号，而BOOTP却固定了，这是因为BOOTP服务器在应答时可能要以广播形式进行，若客户端使用临时端口号，会使得网络中其它主机有可能会接收到该广播信号（碰巧也使用了该临时端口号的话，也就是说采用随机端口号来广播不是一个好的选择）。那为什么客户端口号不用67呢？因为若也是用67，也就是与服务器端口一样的话，那么服务器广播应答到该端口，使得其他服务器可能被唤醒来查看报文，这样也不太好。   

###第17章 TCP：传输控制协议  

TCP提供一种面向连接的、可靠的字节流服务。TCP首部中的源端口号和目的端口号、IP首部中的源端IP地址和目的端IP地址，该四元组唯一确定一个TCP连接。  

* TCP提供可靠性的措施：  
	（1）应用数据被分割成TCP认为最适合发送的数据长度。对比第11章UDP的笔记。  
	（2）当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，若不能及时收到一个确认，将重发这个报文段。收端的确认报文，通常不是立即发送，而是推迟几分之一秒。  
	（3）若收到段的检验和有差错，则丢弃这个报文段且不进行确认（如此，发端会重发）。  
	（4）TCP需要对收到的数据进行重新排序。  
	（5）TCP需要丢弃重复的数据。  
	（6）流量控制，收端会根据自身缓冲区大小来限制发端的速度。  

一个IP和一个端口号也称为一个插口（socket），插口对（socket pair）是一个四元组，可唯一确定一个TCP连接。  
  
* TCP首部中的序号  
	包含发送序号和确认序号。若发端发送了N个字节，则会对发送序号加上N（发送ACK例外，不会让发送序号加1，也就是发送序号不变），下次再发送时便使用该值；确认序号则用于对另一端的确认，是所期望收到的下一个序号。只有ACK标志为1时，确认字段才有效。  
	发送序号初始值(ISN, Initial Sequence Number)的选取，RFC有规定，在0值基础上每0.5秒增加64000，循环。每次建立一个连接，这个变量增加64000.     

###第18章 TCP连接的建立与终止  

* 连接的建立和终止  
	建立时三次握手，终止时四次挥手。三次握手主要是为了获取到确认序号，这就需要两边各发一次，各确认一次，其中，中间的两次可以合并为一条，因此，就是三次握手。而四次挥手，则是可能会用到半关闭，因为TCP是双工的，若只关闭一个方向，另一个方向依旧可以使用，在这种情况下，每个方向进行关闭则主动关闭一方FIN，另一方ACK即可。其实，若不考虑使用半关闭，3次挥手也可以实现(可以参考图18-12，从FIN\_WAIT\_1直接到达TIME\_WAIT状态)。  

* 最大报文段长度（MSS, Maximum Segment Size）  
	发往另一端的最大数据长度（注意，不包含首部），MMS只出现在SYN报文段中。当一个连接建立时，每一方都通告其期望的MMS选项，若一方不接收另一方的MSS值，则MMS就定为默认值536字节。	
* TCP的半关闭  
	一端在结束它的发送后还能接收来自另一端数据的能力。  
	应用场景，主机A和主机B，A在建立连接后，做一些操作（比如给B传递一些数据），在A操作完成时，B再开始进行处理，那么，A操作何时完成，可以通过关闭A到B方向上的连接，这样B可以进行处理，最后将结果发给A  
* TCP的状态变迁图  
	* MSL（Maximum Segment Lifetime）  
		每个TCP具体实现必须选择一个报文段最大生存时间（被丢弃前在网络内的最长时间）。MSL要满足该条件：当TCP执行一个主动关闭，并发回最后一个ACK（即响应对方执行的关闭操作），该连接必须要在TIME\_WAIT状态（发完最后的ACK后就进入该状态，注意，是主动关闭的一方才会进入该状态）停留两倍的MSL。目的：防止最后发送的ACK丢失以便重发。  
		在TIME\_WAIT状态，该socket pair是不能够被使用的，且迟到的报文段将被丢弃。  
	* 平静时间（quiet time）  
		对于出现了故障的TCP，若要防止重新建立的连接接收到原先旧的连接的报文，则要求TCP重启后的MSL秒内不能建立任何连接。这称为平静时间。  
	* FIN\_WAIT\_2  
		主动关闭一端可能会永远在FIN\_WAIT\_2状态，而另一端将处于CLOSE\_WAIT状态。很多实现通过设置一个定时器，若连接空闲一定时间（如10分钟），TCP将关闭。  
* 复位报文段  
	* 到不存在的端口的连接请求  
		注意，此时连接没有建立，只是在请求阶段。请求到达时，目的端口没有进程在监听。  
	* 异常终止一个连接  
		通过发送一个复位报文段而不是FIN来中途释放一个连接，称这为异常释放（abortive release）。收到RST的一方将终止该连接，且不进行确认。  
	* 检测半打开状态  
		若一方已经关闭或异常终止连接而另一方不知道，称这种状态为半打开。  
* 同时打开  
	两边都必须使用对方熟知的端口作为本地端口，我们知道，一个TCP连接即为1个四元组，要使两边同时打开，则要求是在同一个四元组上进行的操作。  
	TCP对于同时打开，仅建立一条连接而不是两条连接。同时打开握手四次。  
	同时打开的过程：（1）两边同时发送SYN；（2）在接收到对方的SYN时(注意，若正常时，本端发送SYN时，应该是接收到SYN和ACK，若是只有SYN，那么可认为同时打开。在接收到SYN时，便将状态切换到SYN\_RCVD)，发送SYN和ACK；（3）当收到对方的SYN和ACK时，状态切换到ESTABLISHED（与图18-12有稍许差异，18-12从SYN\_RCVD到ESTABLISHED只反映了正常的打开情形）。  
* 同时关闭  
	与正常关闭相比，经历的状态变迁不同  
* TCP服务器的设计  
	处于ESTABLISHED状态的连接的端口不会变化，与处于LISTEN状态的进程相同。处于ESTABLISHED状态的进程将不能接收SYN报文段，而处于LISTEN状态的进程不能接收数据报文段。  
	可以限定服务器端监听的IP地址，也可以限定远端IP地址。  
	* 呼入连接请求队列  
		Berkeley的实现：  
		（1）服务器端有一个固定长度的连接队列，该队列中的连接已完成三次握手，但还没有被应用层接受。TCP接受一个连接是将其放入该队列，而应用层接受则是将连接移出该队列。  
		（2）连接队列的最大长度由应用层指定，范围为0-5，通常称为积压值（backlog）  
		（3）当一个SYN到达时，TCP采用相关算法，根据当前连接队列中连接数，来确定是否接收这个连接。  
		（4）存在这种情况，握手完成，但应用层并没有取出该连接，而客户端认为连接建立就可以传输数据了，那么此时TCP层会将接收到的数据放入缓冲队列。可参考图19-4中最后报文段17和18的分析，17发送的数据并没有由报文段18回显过来。    
		（5）当连接队列满时，TCP不接收SYN，也不发回任何报文段，客户端将超时。  
###第19章 TCP的交互数据流  
  
* 经受时延的确认  
	TCP通常在接收到数据时并不立即发送ACK，而是经过一定延时后发送，以便将ACK与需要沿该方向发送的数据一起发送（即数据捎带ACK）。绝大多数实现采用的时延是200ms。若已经有数据需要发送，那么无需时延。  
* Nagle算法  
	一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该组确认到达之前不能发送其它的小分组。该算法有很好的自适应性能，确认到达得越快，数据也就发送得越快。  
    	对于某些应用场景，需要关闭Nagle算法，比如实时性要求很高的交互场景。  
* 窗口大小通告  
	反应了TCP的缓冲区中未被应用程序读取的字节数信息。发送方可以通过接收方的确认序号和可用窗口大小，来计算多少数据可以被立即发送。    


###第20章 TCP的成块数据流  

* 数据流  
	当一个分组到达时，它首先被设备中断程序进行处理，然后放置到IP的输入队列中。使用TCP的滑动窗口协议时，接收方不必确认每一个收到的分组。  
* 滑动窗口  
	发送端记录窗口的位置信息，窗口左右边沿移动有三种情况，窗口合拢、收缩和张开。收缩是右边沿向左移动，RFC强烈建议不要使用此方式。  
* PUSH标志  
    发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。然而，目前大多数API没有向应用程序提供通知其TCP设置PUSH标志的方法。一个好的TCP实现能够自行决定何时设置这个标志。  
* 慢启动，拥塞窗口（congestion window）  
    慢启动为发送方TCP增加了另一个窗口：拥塞窗口，cwnd，建立连接时，拥塞窗口被初始化为1个报文段，每收到一个ACK，拥塞窗口就增加一个报文段。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。  
* 成块数据的吞吐量  
    TCP的自计时（self-clocking）行为：就是接收方在返回ACK时，多个ACK的发送间隔与收到的多个报文的间隔是相同的。  
    连接的理想稳定状态：就是发送方和接收方之间的管道被填满，返回路径上总是有相同数目的ACK。  
    RTT（Round-trip Time）：往返时间。  
    带宽时延乘积：带宽 x RTT  
    拥塞：大管道向小管道发送数据，就有可能发生拥塞。  
* 紧急方式  
    TCP提供了紧急方式，使发送端可告知接收端，紧急数据已经放置到普通数据流中，由接收方决定如何处理。16bit的紧急指针被置为一个正的偏移量，并与TCP首部中的序号字段相加，以便得出紧急数据的最后一个字节的序号（但大多数实现是将其指向紧急数据的最后一个字节的下一个字节）。TCP是没办法指名紧急数据从数据流何处开始，TCP只能告诉紧急方式已经开始（URG比特）和紧急数据的结束位置，其它事情需要应用程序去处理。  
    * 带外数据  
        许多实现称TCP的紧急方式为带外数据，其实这是错误的。若应用程序确实需要一个独立的带外信道，那么最简单的方法是再建立一个TCP连接。相比于TCP，许多其它的运输层协议有真正的带外数据，它们是通过同一个连接的独立逻辑数据通道实现的，这是TCP所没有的。  
    * 紧急方式使用实例  
        Telnet将紧急方式所写的数据流中加入一个值为255的字节作为前缀来标记它所有的命令。  
###第21章 TCP的超时与重传  

* 每个连接所拥有的4个定时器  
    （1）重传定时器，当希望收到另一端确认时使用。  
    （2）坚持（persist）定时器，在发送方开始等待允许它继续发送的窗口更新时，启动该定时器，以便发现窗口是否已经增大。  
    （3）保活定时器，可检测到一个空闲连接的另一端何时崩溃或重启。  
    （4）2MSL定时器。  
    关于定时器的使用方式，参考图18-7。BSD版通过使用500ms的定时器实现，也就是说，从开始计算超时开始，对每500ms一次的tick进行计数（注意，这里的500ms起始并不由TCP控制，也就是说超时开始计数时，可能不是刚好在tick的节点，也就是会有0-499ms的误差）.   

* RTT的测量  
    RTT考虑了当前实际所测量到的值，以及之前保存的RTT值，更新得到的RTT值称为平滑的RTT。大多数源于Berkeley的TCP实现在任何时候对每个连接仅测量一次RTT值，在发送一个报文段时，若给定连接的定时器已经被使用，则该报文段不被计时。对计时的报文段（只有数据报文段才会被计时，SYN这种报文段是不会被计时的），收到该报文段的确认后（存下该报文段的起始序号，根据返回的ACK所确认的序号，由此可以推知是否是对该报文的确认），即可得到RTT的测量值，同时关闭定时器。  
* 重传的多义性问题  
    在重传之后，若收到一个确认，是无法判断是原先分组的确认还是重传分组的确认。由上面RTT的测量所知，在收到ACK时，是需要进行RTT的平滑计算的（当然，要保证该报文被计时），由于不知道是对哪个报文进行确认，也就无法确定起始时间，那么Karn算法规定，在重传数据最后到达时，不能更新RTT。  
* RTO（Retransmission TimeOut，重传超时时间）的计算   
    初始化：RTO = A + 2D，以后更新：RTO = A + 4D  
* 拥塞避免算法  
    该算法是一种处理丢失分组的方法，其假定由于分组受到损坏引起的丢失是非常少的，而主要是因为网络阻塞而引起的丢失。  
    两种分组丢失的指示：（1）发生超时；（2）收到重复的确认。  
    当拥塞发生时，我们希望降低分组进入网络的传输速率。  
    拥塞算法需要维护拥塞窗口cwnd和慢启动门槛ssthresh，算法过此如下。  
    （1）对于一个给定的TCP连接，初始化cwnd为一个报文段，ssthresh为65535个字节  
    （2）当拥塞发生时（超时/收到重复确认），若是超时引起，则cwnd被设置为1个报文段；不论哪种情况，ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口的较小值），且ssthresh最少为2个报文段。  
    （3）当新数据被确认时，增加cwnd，在cwnd<=ssthresh时，执行慢启动；否则，执行拥塞避免，也就是cwnd为加性增长，也就是在一个RTT内最多增加1个报文段，而不论收到多少ACK。

* 快速重传与快速恢复算法  
    对于一些报文段的重新排序，可能会有少量重复ACK到来<font color='red'>（具体场景我也不懂）</font>。若一连串收到3个或以上的重复ACK，则非常可能是一个报文段丢了，此时无需等待超时定时器溢出，这就是快速重传算法。而且接下来执行的不是慢启动算法而是拥塞避免算法，这就是快速恢复算法。为什么使用快速恢复算法，是因为接收方只有在收到另一个报文段时才会产生重复的ACK，而该报文段已经离开了网络并进入了接收方的缓存，也就是说，收发两端之间仍有流动的数据，而我们不想执行慢启动来突然减少数据流。  

* 按每条路由进行度量  
    对于之前介绍的RTT，D， ssthresh，输入输出带宽时延乘积，等这些指标已增加到路由表项中，这样，建立一个新的连接时，就可以使用这些值。  
* ICMP的差错  
    TCP常遇到的有源站抑制、主机不可达和网络不可达。基于Berkely的实现是这样，对于源站抑制，cwnd被设置为1并发起慢启动，而ssthresh不变。对于不可达，则直接忽略，但会记录，以便必要时产生合适的差错码。  
* 重新分组  
    当TCP超时并重传时，它不一定要重传同样的报文段。
###第22章 TCP的坚持定时器  

第21章的笔记对坚持定时器做了初步介绍。对于窗口探查，TCP是会一直进行下去，这个过程持续到窗口被打开或者连接被终止。  

* 糊涂窗口综合症（SWS，Silly Window Syndrome）    
    现象：这种情况发生时，只有少量数据将通过连接进行交换，而不是满长度的报文段。  
    原因：接收方只通告一个小窗口（而不是一直等到有大的窗口时才通告）；发送方也可以发送少量数据（而不是等待其它的数据以便发送一个大的报文段）。  
    如何避免：（1）接收方不通告小窗口；（2）发送方则要在以下条件满足时才进行发送，具体条件参考书本P247  

###第23章 TCP的保活定时器  

RFC不推荐使用保活定时器，原因有3点：   
（1）可能只是一个很好的连接出现了短暂差错；  
（2）耗费不必要的带宽  
（3）按分组计费花费更高  

保活功能试图在服务器端检测半开放的连接。一般只有服务器端使用保活选项，若客户端也需要了解对方是否已经消失，则也可以使用这个选项。  
###第24章 TCP的未来和性能  

* 路径MTU发现  
      
          
###参考  
[pseudo_header_url]:"http://www.postel.org/pipermail/end2end-interest/2005-February/004616.html"

